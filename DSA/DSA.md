# learning-resources
reference material for personal use

DSA:

Here's a list of core concepts you should master to effectively solve LeetCode questions:

### 1. **Data Structures**
   - **Arrays and Strings**
     - Traversal, manipulation, and operations (sorting, searching).
     - Sliding window technique.
   - **Linked Lists**
     - Single and double linked lists.
     - Operations like insertion, deletion, reversal.
   - **Stacks and Queues**
     - Stack-based algorithms (e.g., balancing parentheses).
     - Queue operations and priority queues.
   - **Trees and Graphs**
     - Binary Trees (BST, AVL, Red-Black).
     - Tree traversal methods (inorder, preorder, postorder).
     - Graph representations (adjacency list, adjacency matrix).
     - Graph traversal algorithms (DFS, BFS).
   - **Heaps**
     - Max-heap, min-heap.
     - Priority queue operations.
   - **Hash Tables**
     - Implementations using arrays, handling collisions.
     - Common operations like insert, delete, search.
   - **Tries**
     - Prefix trees for string search.
     - Operations like insert, search, and delete.
   - **Disjoint Sets**
     - Union-find algorithms with path compression and union by rank.
   - **Binary Indexed Trees (Fenwick Trees) and Segment Trees**
     - Range queries and updates.

### 2. **Algorithms**
   - **Sorting and Searching**
     - Quick Sort, Merge Sort, Heap Sort.
     - Binary Search and its variants.
   - **Dynamic Programming**
     - Identifying overlapping subproblems and optimal substructure.
     - Bottom-up vs. top-down approaches (tabulation vs. memoization).
   - **Greedy Algorithms**
     - Making locally optimal choices.
     - Common problems like interval scheduling, coin change.
   - **Backtracking**
     - Solving problems like permutations, combinations, and N-Queens.
   - **Divide and Conquer**
     - Algorithms like Merge Sort, Quick Sort, Binary Search.
   - **Bit Manipulation**
     - Operations like XOR, bitwise shifts.
     - Tricks for problems like finding the single non-duplicate element.
   - **Graph Algorithms**
     - Dijkstra’s, Bellman-Ford for shortest path.
     - Floyd-Warshall for all-pairs shortest path.
     - Kruskal’s and Prim’s for minimum spanning tree.
   - **Two Pointers**
     - Techniques for problems involving arrays and linked lists.
   - **Sliding Window**
     - Efficiently finding subarrays or substrings that satisfy a condition.

### 3. **Mathematical Concepts**
   - **Number Theory**
     - GCD, LCM, prime factorization, modular arithmetic.
   - **Combinatorics**
     - Permutations, combinations, Pascal's Triangle.
   - **Probability and Statistics**
     - Basic probability concepts applied in randomized algorithms.
   - **Geometry**
     - Problems involving points, lines, and shapes.

### 4. **Problem-Solving Techniques**
   - **Brute Force vs. Optimization**
     - Identifying when to apply brute force and when to optimize.
   - **Recursion**
     - Base cases and recursive cases.
     - Avoiding stack overflow and improving with memoization.
   - **Pattern Recognition**
     - Identifying common patterns in problem statements.
   - **Trade-offs**
     - Space vs. time complexity, iterative vs. recursive solutions.

### 5. **Big O Notation**
   - **Time Complexity**
     - Analyzing the time cost of different algorithms.
   - **Space Complexity**
     - Understanding the memory usage of different solutions.

### 6. **Practice with Common Problem Types**
   - **Array Problems**
     - Subarray sums, Kadane's algorithm.
   - **String Problems**
     - Palindrome checking, string matching (KMP algorithm).
   - **Tree Problems**
     - Lowest common ancestor, tree serialization/deserialization.
   - **Graph Problems**
     - Shortest path, connectivity checks.
   - **Dynamic Programming Problems**
     - Fibonacci sequence, knapsack problem, longest increasing subsequence.
   - **Greedy Problems**
     - Interval scheduling, activity selection.

### 7. **LeetCode Patterns**
   - Focus on common patterns like:
     - **Top K Elements**: Using heaps or quick select.
     - **Merge Intervals**: Interval merging techniques.
     - **Fast & Slow Pointers**: For detecting cycles, palindrome checks.
     - **Subsets/Permutations**: Recursion and backtracking.
     - **Matrix Traversal**: DFS/BFS in 2D grids.

### 8. **Optimization Techniques**
   - **Memoization**: Store results of expensive function calls and reuse.
   - **Tabulation**: Iteratively build up solutions.
   - **Space Optimization**: Reduce space complexity by reusing variables.

### 9. **Testing and Debugging**
   - **Edge Cases**
     - Consider extreme cases like empty inputs, very large inputs.
   - **Input Validation**
     - Ensure the algorithm handles invalid inputs gracefully.
   - **Step-by-Step Execution**
     - Walk through the algorithm with sample inputs.

### 10. **LeetCode-Specific Tips**
   - **Start with Easy Problems:** Build confidence and understanding.
   - **Participate in Contests:** Improve speed and efficiency.
   - **Read Discussions:** Learn from the community’s solutions.
   - **Consistent Practice:** Daily practice helps in retaining concepts.

Mastering these concepts will significantly improve your ability to tackle LeetCode problems effectively.
